https://github.com/shadowsocks/shadowsocks
https://github.com/xtaci/kcptun
https://github.com/wangyu-/udp2raw-tunnel
https://bwh1.net/cart.php?a=confproduct&i=0




[root@bogon nginx]# mysql_install_db
Installing MariaDB/MySQL system tables in '/var/lib/mysql' ...
2017-11-06  8:45:06 140654764091712 [Note] /usr/libexec/mysqld (mysqld 10.1.26-MariaDB) starting as process 6413 ...
OK
Filling help tables...
2017-11-06  8:45:09 140360610146624 [Note] /usr/libexec/mysqld (mysqld 10.1.26-MariaDB) starting as process 6445 ...
OK
Creating OpenGIS required SP-s...
2017-11-06  8:45:12 139837183658304 [Note] /usr/libexec/mysqld (mysqld 10.1.26-MariaDB) starting as process 6475 ...
OK

To start mysqld at boot time you have to copy
support-files/mysql.server to the right place for your system

PLEASE REMEMBER TO SET A PASSWORD FOR THE MariaDB root USER !
To do so, start the server, then issue the following commands:

'/usr/bin/mysqladmin' -u root password 'new-password'
'/usr/bin/mysqladmin' -u root -h bogon password 'new-password'

Alternatively you can run:
'/usr/bin/mysql_secure_installation'

which will also give you the option of removing the test
databases and anonymous user created by default.  This is
strongly recommended for production servers.

See the MariaDB Knowledgebase at http://mariadb.com/kb or the
MySQL manual for more instructions.

You can start the MariaDB daemon with:
cd '/usr' ; /usr/bin/mysqld_safe --datadir='/var/lib/mysql'

You can test the MariaDB daemon with mysql-test-run.pl
cd '/usr/mysql-test' ; perl mysql-test-run.pl

Please report any problems at http://mariadb.org/jira

The latest information about MariaDB is available at http://mariadb.org/.
You can find additional information about the MySQL part at:
http://dev.mysql.com
Consider joining MariaDB's strong and vibrant community:
https://mariadb.org/get-involved/

		{"status":0,"info":"session_start(): Cannot send session cookie - headers already sent by (output started at \/home2\/xinshangyun\/developv3\/extend\/com\/Pay\/WeiXin.php:268)","url":""}

    “Warning： Cannot send session cookie - headers already sent。。。”或者“Cannot add header information - headers already sent。。。”。
    函数 header()，setcookie() 和 session 函数需要在输出流中增加头信息。但是头信息只能在其它任何输出内容之前发送。在使用这些函数前不能有任何（如 HTML）的输出。函数 headers_sent() 能够检查您的脚本是否已经发送了头信息。请参阅“输出控制函数”。
    意思是：不要在使用上面的函数前有任何文字，空行，回车，空格等。但。。。问题是，这答案并不令人满意。因为往往程序在其他PHP环境下运行却正常。
    首先：这错误是怎么产生的呢？让我们来看看PHP是如何处理HTTP header输出和主体输出的。
    PHP脚本开始执行时，它可以同时发送header(标题)信息和主体信息。 Header信息(来自 header() 或 SetCookie() 函数)并不会立即发送，相反，它被保存到一个列表中。 这样就可以允许你修改标题信息，包括缺省的标题(例如 Content-Type 标题）。但是，一旦脚本发送了任何非标题的输出（例如，使用 HTML 或 print() 调用)，那么PHP就必须先发送完所有的Header，然后终止 HTTP header。而后继续发送主体数据。从这时开始，任何添加或修改Header信息的试图都是不允许的，并会发送上述的错误消息之一。
    笨方法：把错误警告全不显示!
    掩耳盗铃之计，具体方法就不说了 ^_^#
    解决方案：
    1)适用于有权限编辑PHP。INI的人
    打开php。ini文件(你应试比我清楚你的php。ini在哪里)，找到
    output_buffering =改为on或者任何数字。如果是IIS6，请一定改为ON，不然你的PHP效率会奇慢。
    2)使用虚拟主机，不能编辑PHP。INI，怎么办？
    简单：
    在你的空间根目录下建立一个.htaccess文件，内容如下：
    AllowOverride All
    PHP_FLAG output_buffering On
    不幸的情况是：还是不行？全部网页都不能显示啦？
    那么，你可以打电话骂一通空间商，然后让他给你把apache的。htaccess AllowOverride打开
    3)在PHP文件里解决
    ob_start()
    启用output buffering机制。 Output buffering支持多层次 -- 例如，可以多次调用 ob_start() 函数。
    ob_end_flush()
    发送output buffer（输出缓冲）并禁用output buffering机制。
    ob_end_clean()
    清除output buffer但不发送，并禁用output buffering。
    ob_get_contents()
    将当前的output buffer返回成一个字符串。允许你处理脚本发出的任何输出。
    原理：
    output_buffering被启用时，在脚本发送输出时，PHP并不发送HTTP header。相反，它将此输出通过管道（pipe）输入到动态增加的缓存中（只能在PHP 4。0中使用，它具有中央化的输出机制）。你仍然可以修改/添加header，或者设置cookie，因为header实际上并没有发送。当全部脚本终止时，PHP将自动发送HTTP header到浏览器，然后再发送输出缓冲中的内容。






    在CentOS7中运行NodeJs的容器，发现挂载的本地目录在容器中没有执行权限，经过各种验证和Google搜索，找到了问题的原因，这里做一下记录。原因是CentOS7中的安全模块selinux把权限禁掉了，至少有以下三种方式解决挂载的目录没有权限的问题：

    1，在运行容器的时候，给容器加特权：

    示例：docker run -i -t --privileged=true -v /home/docs:/src waterchestnut/nodejs:0.12.0

    2，临时关闭selinux：

    示例：su -c "setenforce 0"

    之后执行：docker run -i -t -v /home/docs:/src waterchestnut/nodejs:0.12.0

    注意：之后要记得重新开启selinux，命令：su -c "setenforce 1"

    3，添加selinux规则，将要挂载的目录添加到白名单：

    示例：chcon -Rt svirt_sandbox_file_t /home/docs

    之后执行：docker run -i -t -v /home/docs:/src waterchestnut/nodejs:0.12.0

    CentOS 6/7系列安装Docker http://www.linuxidc.com/Linux/2014-07/104768.htm

    Docker的搭建Gitlab CI 全过程详解 http://www.linuxidc.com/Linux/2013-12/93537.htm

    Docker安装应用(CentOS 6.5_x64) http://www.linuxidc.com/Linux/2014-07/104595.htm

    在 Docker 中使用 MySQL http://www.linuxidc.com/Linux/2014-01/95354.htm

    在Ubuntu Trusty 14.04 (LTS) (64-bit)安装Docker http://www.linuxidc.com/Linux/2014-10/108184.htm

    Docker安装应用(CentOS 6.5_x64) http://www.linuxidc.com/Linux/2014-07/104595.htm

    Ubuntu 14.04安装Docker  http://www.linuxidc.com/linux/2014-08/105656.htm

    阿里云CentOS 6.5 模板上安装 Docker http://www.linuxidc.com/Linux/2014-11/109107.htm

    Docker 的详细介绍：请点这里
    Docker 的下载地址：请点这里

    本文永久更新链接地址：http://www.linuxidc.com/Linux/2015-03/115123.htm








http://database.51cto.com/art/201711/559266.htm?utm_source=tuicool&utm_medium=referral
https://www.tuicool.com/articles/AjqYna2
https://www.sitepoint.com/using-php-streams-effectively/
https://www.tuicool.com/articles/UBfEvmmhttps://www.tuicool.com/articles/I3yI3u2
phppid
ngpid

webserver()
{

  $argv[1]
  $argv[2]


  case "$argv[1]"
    "nginx")


    ;;
    "php")


    ;;
    *)
      case "$argv[1]"
        "start")

        ;;
        "stop"
      esac
    ;;

  esac




  case
    start)


    ;;
    stop)


    ;;
    reload)






  esac

}


https://www.tuicool.com/articles/iUbYRvR
https://www.tuicool.com/articles/Mzeeu2R
https://www.tuicool.com/articles/6RJjAfZ
https://www.tuicool.com/articles/7VRnIbF
https://www.tuicool.com/articles/iUbYRvR
https://www.tuicool.com/articles/NVJzYnn
https://www.tuicool.com/articles/jEVn6ry


开启单任务，关闭单任务


nohup是永久执行

&是指在后台运行

运行 nohup --help
Run COMMAND, ignoring hangup signals. 可以看到是“运行命令，忽略挂起信号”

就是指，用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响他的运行，注意了nohup没有后台运行的意思；&才是后台运行

&是指在后台运行，但当用户推出(挂起)的时候，命令自动也跟着退出

那么，我们可以巧妙的吧他们结合起来用就是
nohup COMMAND &
这样就能使命令永久的在后台执行

举个例子nohup tail -f nohup.out
然后退出登录，再连接，用ps -ef 你会还能看到在运行
ps -ef
root      3457     1  0 18:20 ?        00:00:00 tail -f nohup.out

另外，nohup执行后，会产生日子文件，把命令的执行中的消息保存到这个文件中，一般在当前目录下，如果当前目录不可写，那么自动保存到执行这个命令的用户的home目录下，例如root的话就保存在/root/下

这个我们常在运行命令和脚本中常用到的







mysql命令gruop by报错this is incompatible with sql_mode=only_full_group_by

在mysql 工具 搜索或者插入数据时报下面错误：
ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column 'database_tl.emp.id' which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by

原因：
看一下group by的语法：
select 选取分组中的列+聚合函数 from 表名称 group by 分组的列
从语法格式来看，是先有分组，再确定检索的列，检索的列只能在参加分组的列中选。
我当前Mysql版本5.7.17，
再看一下ONLY_FULL_GROUP_BY的意思是：对于GROUP BY聚合操作，如果在SELECT中的列，没有在GROUP BY中出现，那么这个SQL是不合法的，因为列不在GROUP BY从句中，也就是说查出来的列必须在group by后面出现否则就会报错，或者这个字段出现在聚合函数里面。

查看mysql版本命令：select version();
查看sql_model参数命令：
SELECT @@GLOBAL.sql_mode;
SELECT @@SESSION.sql_mode;
发现：
ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
第一项默认开启ONLY_FULL_GROUP_BY，

解决方法：
1.只选择出现在group by后面的列，或者给列增加聚合函数；（不推荐）
2.命令行输入：
set @@GLOBAL.sql_mode='';
set sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';

默认关掉ONLY_FULL_GROUP_BY！

这个时候 在用工具select 一下
SELECT @@sql_mode;
SELECT @@GLOBAL.sql_mode;

发现已经不存在ONLY_FULL_GROUP_BY ，感觉已经OK。但是如果你重启Mysql服务的话，发现ONLY_FULL_GROUP_BY还是会存在的

想要彻底解决这个问题 就得去改my.ini 配置（如果你们mysql 没有这个文件，就把my-default.ini 改成my.ini，我这个版本就是没有my.ini配置问题）

在 [mysqld]和[mysql]下添加
SET sql_mode ='STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';


update user set authentication_string = password('root') where user = 'root';
将root的密码改为root。 接着，由于mysql中root执行绑定在了localhost，因此需要对root进行授权，代码如下，

GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;




https://www.tuicool.com/articles/ieIJ7vI
https://www.tuicool.com/articles/FVBBZri
https://www.tuicool.com/articles/AVb6feQ
https://www.tuicool.com/articles/mIZ7niZ
https://zhuanlan.zhihu.com/p/31098011
https://www.tuicool.com/articles/zUJ7Rb
https://www.tuicool.com/articles/Yvq6RvA
https://www.tuicool.com/articles/rMNv22Q
https://www.tuicool.com/articles/FjYbAvI
https://www.tuicool.com/articles/MFrEnaJ
https://www.tuicool.com/articles/q6bINjb
https://www.tuicool.com/articles/YVzE7vy
https://www.tuicool.com/articles/EN7RV3R
https://www.tuicool.com/articles/JZFVzer
https://www.tuicool.com/articles/aMr2ayj
http://blog.csdn.net/stpeace/article/details/53512283
http://blog.opskumu.com/mysql-blob.html
https://www.tuicool.com/articles/mENbq2e
https://www.tuicool.com/articles/BzANzu7
https://www.tuicool.com/articles/36JRnqJ
https://www.tuicool.com/articles/JR7z6rM
http://blog.csdn.net/nuli888/article/details/51892776
rpm -E %fedora
yum install --nogpgcheck http://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-$(rpm -E %fedora).noarch.rpm http://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-$(rpm -E %fedora).noarch.rpm
https://www.tuicool.com/articles/mmyiAbz
https://www.tuicool.com/articles/NN7RrmA
https://www.tuicool.com/articles/IFnIFvF
https://www.tuicool.com/articles/ve6Vbe7
https://www.tuicool.com/articles/BFR3ean
https://www.tuicool.com/articles/r6v2Yn3
https://www.tuicool.com/articles/2Mryiib
https://www.tuicool.com/articles/bUBviaY
# ethtool -s eth0 wol g
这条命令可能会在重启后失效，所以为了确保万无一失，你可以创建个 root 用户的定时任务（cron）在每次重启的时候来执行这条命令。

@reboot /usr/bin/ethtool -s eth0 wol g

这里有一个可以用于设置密码的地方，但是如果你的网络接口不支持安全开机密码，它就不起作用。

现在你需要配置第二台计算机来发送唤醒信号。你并不需要 root 权限，所以你可以为你的普通用户创建 cron 任务。你需要用到的是想要唤醒的机器的网络接口和MAC地址信息。

30 08 * * * /usr/bin/wakeonlan D0:50:99:82:E7:2B

这是我翻墙用的协议的github地址
https://github.com/shadowsocks
有Python版和go版
https://github.com/shadowsocks/shadowsocks
https://github.com/xtaci/kcptun
https://github.com/wangyu-/udp2raw-tunnel
https://bwh1.net/cart.php?a=confproduct&i=0


https://www.tuicool.com/articles/m6vuqiI
https://www.tuicool.com/articles/FzuiQrQ
https://www.tuicool.com/articles/QRRnym2
https://www.tuicool.com/articles/QRRnym2
https://www.tuicool.com/articles/fiQBfer
https://www.tuicool.com/articles/fiQBfer

https://www.tuicool.com/articles/vYjaqm6
https://www.tuicool.com/articles/juQ36rU
https://www.tuicool.com/articles/vqeeEn2



列出您 Linux 系统上的所有单元
systemctl list-unit-files

要限制输出列表只包含服务，使用以下命令
systemctl list-unit-files --type=service

systemctl status gdm.service

启动目标 （target）是一种将多个单元聚合在一起以致于将它们同时启动的方式。
文本模式的 multi-user.target 类似于第3运行级，graphical.target 类似于第5运行级，reboot.target 类似于第6运行级
若某个单元被禁用了，您可以先通过 systemctl enable 加上该单元名的方式将其使能。这种做法会为该单元创建一个符号链接，并将其放置在当前启动目标的 .wants 目录下，这些 .wants 目录在/etc/systemd/system 文件夹中。

http://www.ruanyifeng.com/blog/2017/11/bash-set.html
https://linux.cn/article-8601-1.html
https://linux.cn/article-9047-1.html
https://www.cnblogs.com/sudawei/p/3345808.html
http://www.cnblogs.com/kidsitcn/p/4526562.html
https://www.cnblogs.com/sudawei/p/3345808.html
http://www.isaced.com/post-248.html
https://www.tuicool.com/articles/7fIbqeB
https://www.tuicool.com/articles/ru6baqU

https://www.tuicool.com/articles/EvUfeqf
https://www.tuicool.com/articles/YNnEjqm
https://www.tuicool.com/articles/jIRB7bR
https://www.tuicool.com/articles/UBfEvmm
https://www.tuicool.com/articles/Qfe6jqI
https://www.tuicool.com/articles/yqQZBjV
https://www.tuicool.com/articles/BvuQ7nz
https://www.tuicool.com/articles/b6NJBnf
http://www.cnblogs.com/linguanh/p/8000063.html
https://www.tuicool.com/articles/bYVz2iJ
https://www.tuicool.com/articles/yM36Bv7
